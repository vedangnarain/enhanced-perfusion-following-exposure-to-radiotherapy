#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed May 17 16:13:24 2023

Tested in Python 3.7.4.

Generate the diffusion map from a line source.
 
"""

# =============================================================================
# LIBRARIES & INITIALISATION
# =============================================================================

# Initialise libraries
import numpy as np
# import matplotlib.colors as colors
import matplotlib.pyplot as plt
# import sympy as sp
import matplotlib.animation as animation
# from matplotlib.animation import FuncAnimation
import time

# Starts stopwatch to clock execution time
start_time = time.time()

# =============================================================================
# KEY PARAMETERS
# =============================================================================

# Define the domain size in microns
vessel_length = 100 
vessel_height = (pow(2,0.5)*vessel_length)*0.5
domain_x = int(vessel_height+vessel_height+vessel_length+vessel_length+0.0001)
mid_domain_x = int(domain_x*0.5)

# Set the grid element size in microns
grid_spacing = 1

# Set the key terms of the diffusion equation and convert them to the right units
diffusion_coefficient_cm_sq_per_min = 0.00145
diffusion_coefficient_um_sq_per_min = diffusion_coefficient_cm_sq_per_min*1e+8
vessel_permeability_per_cm_per_min = 6
vessel_permeability_per_um_per_min = vessel_permeability_per_cm_per_min/10000
c_stp_mol_per_metre_cube = 1/0.0224
c_stp_mol_per_um_square = c_stp_mol_per_metre_cube/1e+12
p_ref_mmHg = 20
alpha_eff_per_mmHg = 3.1*(10**(-5))
c_ref = c_stp_mol_per_um_square * p_ref_mmHg * alpha_eff_per_mmHg
ref_haematocrit = 0.45
consumption_rate = 13

# Set the number of iterations (minutes)
max_iter = 100

# Specify the maximum tolerated difference (moles) between time steps for convergence 
# tolerance = 0.000000001  # 1 nM 
tolerance = 0 

# =============================================================================
# GENERATE THE SOLUTION
# =============================================================================

# Define a function to compute the oxygen field for a vessel given its start and end nodes and scaled haematocrit (rough way to reduce the amount of haematocrit in a vessel)
# def get_solution(start_node, end_node, vessel_haematocrit = 0.45):
def get_solution(length, y_position, vessel_haematocrit = 0.45):
    
    # vessel_points = get_diagonal_coordinates(start_node, end_node)
    
    # Initialize solution: the grid of u(i, j)
    c = np.empty((max_iter, domain_x, domain_x))
    
    # Initial condition everywhere inside the grid
    c_initial = 0.0
    
    # Boundary conditions
    # u_top = 0.0
    # u_left = 0.0
    # u_bottom = 0.0
    # u_right = 0.0
    
    # Set the initial condition
    c.fill(c_initial)
    
    # Set the boundary conditions
    # u[(domain_x-1):, :] = u_top
    # u[:, 0] = u[:, 1]
    # u[:, -1] = u[:, -2]
    # u[0, :] = u[1, :]
    # u[-1, :] = u[-2, :]    

    # Create a loop to update each grid element    
    for k in range (0, max_iter-1):
    
        # Update all points except those at the boundary
        for i in range(1, domain_x-1):  # Loop over non-boundary cells
          for j in range(1, domain_x-1):  # Loop over non-boundary cells
              
            # Sum up the concentration in the neighbouring cells  
            neighbourhood = c[k][i+1][j] + c[k][i-1][j] + c[k][i][j+1] + c[k][i][j-1]
            
            # If the grid element is where a vessel should be, update the element with a source term in the equation
            if i==y_position and j<=length:
            # if (i,j) in vessel_points:
                vessel_diameter_um = 10
                # vessel_haematocrit = 0.45
                vessel_delivery = np.pi * vessel_diameter_um * vessel_permeability_per_um_per_min  # delta*pi*d*xi
                numerator = (vessel_delivery * c_ref * vessel_haematocrit/ref_haematocrit) + (diffusion_coefficient_um_sq_per_min * neighbourhood/(grid_spacing**2))
                denominator = (4 * diffusion_coefficient_um_sq_per_min/(grid_spacing**2)) + vessel_delivery + consumption_rate
                c[k + 1, i, j] = numerator/denominator
    
                '''
                # Compare the solutions generated by my rearranged equation and the SymPy representation of the diffusion equation.
                c = sp.symbols('c')
                equation = (diffusion_coefficient_um_per_min*(neighbourhood-4*c)/(grid_spacing**2)) + vessel_delivery*((c_ref*vessel_haematocrit/ref_haematocrit)-c) - consumption_rate*c
                solutions = sp.solve(equation, c)
                for solution in solutions:
                    print(iteration, i, j)
                    print(f"x = {solution}")
                    print( u_new[i, j])
                '''
            
            # If the grid element has no vessel, update the element without a source term in the equation
            else:
                numerator = diffusion_coefficient_um_sq_per_min * neighbourhood/(grid_spacing**2)
                denominator = (4 * diffusion_coefficient_um_sq_per_min/(grid_spacing**2)) + consumption_rate
                c[k + 1, i, j] = numerator/denominator
        
        # Set up a no-flux boundary condition
        c[k + 1,:, 0] = c[k + 1,:, 1]
        c[k + 1,:, -1] = c[k + 1,:, -2]
        c[k + 1,0, :] = c[k + 1,1, :]
        c[k + 1,-1, :] = c[k + 1,-2, :]
    
        # Mark the number of iterations required
        print(k)
        req_iterations = k+1
    
        # If the difference between the new and old matrix is not substantial, the solution has converged
        if np.abs(np.sum(c[k + 1, :, :])-np.sum(c[k, :, :])) <= tolerance:
            print('SOLUTION HAS CONVERGED!')
            break
    
        # If we've reached the last iteration without convergence, display the warning
        if req_iterations == max_iter-1:
            print('SOLUTION FAILED TO CONVERGE!')

    return c, req_iterations

# def get_diagonal_points(matrix, start_x, start_y, end_x, end_y):
#     # make start_x <= end_x, if you don't need to check, remove this line
#     if start_x > end_x:
#         start_x, start_y, end_x, end_y = end_x, end_y, start_x, start_y

#     result = []
#     slope = (end_y - start_y) // (end_x - start_x)
#     for i, j in zip(range(start_x, end_x), range(start_y, end_y, slope)):
#         result.append(matrix[i][j])
#     result.append(matrix[end_x][end_y])  # add end point
#     return result
def get_diagonal_coordinates(start, end):
    coordinates = []
    x1, y1 = start
    x2, y2 = end

    dx = abs(x2 - x1)
    dy = abs(y2 - y1)

    # Determine the increments for x and y
    sx = 1 if x1 < x2 else -1
    sy = 1 if y1 < y2 else -1

    # Initialize the error term
    error = dx - dy

    # Start from the starting point and add coordinates until the end point is reached
    while x1 != x2 or y1 != y2:
        coordinates.append((x1, y1))

        # Calculate the next coordinates
        error2 = 2 * error

        if error2 > -dy:
            error -= dy
            x1 += sx

        if error2 < dx:
            error += dx
            y1 += sy

    # Add the end point
    coordinates.append((x1, y1))

    return coordinates

vessel_1, req_iterations = get_solution(100, mid_domain_x, 0.45)
# vessel_2, req_iterations = get_solution(domain_x, mid_domain_x+50, 0.32)
# vessel_3, req_iterations = get_solution(domain_x, mid_domain_x-50, 0.49)
# vessel_4, req_iterations = get_solution(domain_x, mid_domain_x-60, 0.32)
# vessel_5, req_iterations = get_solution(domain_x, mid_domain_x-70, 0.49)

'''
# vessel_1, req_iterations = get_solution((mid_domain_x, 0), (mid_domain_x, 100))
# vessel_2, req_iterations = get_solution((mid_domain_x, vessel_length), (vessel_height+mid_domain_x, vessel_height+vessel_length))
# vessel_3, req_iterations = get_solution((mid_domain_x, vessel_length), (-vessel_height+mid_domain_y, vessel_height+vessel_length))
# vessel_2, req_iterations = get_solution((mid_domain_x, vessel_length), (vessel_height+mid_domain_x, vessel_height+vessel_length))

// Set nodes based on an equilateral network
std::shared_ptr<VesselNode<2> > p_node_1 = VesselNode<2>::Create(0.0_um, mid_domain_y);
std::shared_ptr<VesselNode<2> > p_node_2 = VesselNode<2>::Create(vessel_length, mid_domain_y);
std::shared_ptr<VesselNode<2> > p_node_3 = VesselNode<2>::Create(vessel_height+vessel_length, vessel_height+mid_domain_y);
std::shared_ptr<VesselNode<2> > p_node_4 = VesselNode<2>::Create(vessel_height+vessel_length, -vessel_height+mid_domain_y);
std::shared_ptr<VesselNode<2> > p_node_5 = VesselNode<2>::Create(vessel_height+vessel_height+vessel_length, mid_domain_y);
std::shared_ptr<VesselNode<2> > p_node_6 = VesselNode<2>::Create(vessel_height+vessel_height+vessel_length+vessel_length, mid_domain_y);
std::shared_ptr<VesselNode<2> > p_node_7 = VesselNode<2>::Create(domain_x, mid_domain_y);  // add a node at a distance of 100 picometres from the last node to work around glitch of disconnected flow when setting p_node_6 as the output node

// Make segments 
std::shared_ptr<VesselSegment<2> > p_segment_1 = VesselSegment<2>::Create(p_node_1, p_node_2);
std::shared_ptr<VesselSegment<2> > p_segment_2 = VesselSegment<2>::Create(p_node_2, p_node_3);
std::shared_ptr<VesselSegment<2> > p_segment_3 = VesselSegment<2>::Create(p_node_2, p_node_4);
std::shared_ptr<VesselSegment<2> > p_segment_4 = VesselSegment<2>::Create(p_node_3, p_node_5);
std::shared_ptr<VesselSegment<2> > p_segment_5 = VesselSegment<2>::Create(p_node_4, p_node_5);
std::shared_ptr<VesselSegment<2> > p_segment_6 = VesselSegment<2>::Create(p_node_5, p_node_6);
std::shared_ptr<VesselSegment<2> > p_segment_7 = VesselSegment<2>::Create(p_node_6, p_node_7);
'''

# Sum up the oxygen maps from different vessels
compound = vessel_1# +vessel_2+vessel_3+vessel_4+vessel_5

# Define a function to plot a single solution in time
def plot_diffusion_map(c_k, k):
    # Clear the current plot figure
    # plt.figure(figsize=(5,5))
    plt.clf()
    plt.title(f"Concentration (M) after {k-1} minutes")
    plt.xlabel("x")
    plt.ylabel("y")
    plt.pcolormesh(c_k, cmap=plt.cm.coolwarm, vmin=np.min(c_k), vmax=np.max(c_k))
    plt.colorbar()
    return plt

# Define a function to animate the diffusion spread over time
def animate(k):
    plot_diffusion_map(compound[k], k)

# Plot the final time step
animate(req_iterations)

# Animate the solution
anim = animation.FuncAnimation(plt.figure(), animate, interval=1, frames=req_iterations+1, repeat=False)
anim.save("oxygen_solution.gif")

# Prints execution time
print("\n--- Execution Time: %s seconds ---" % (time.time() - start_time))
